
#define INC_FLEN
#define COMMON_SKIP_BSF
#include "common.inc"

byte L_LUT[256] = {
0x00,0x00,0x01,0x02,0x03,0x05,0x04,0x06,0x07,0x0B,0x09,0x0D,0x08,0x0C,0x0A,0x0E,
0x0F,0x1E,0x2D,0x3C,0x4B,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB4,0xC3,0xD2,0xE1,0xF0,
0x10,0x11,0x1F,0x20,0x2E,0x2F,0x3D,0x3E,0x4C,0x4D,0x5B,0x5C,0x6A,0x6B,0x79,0x7A,
0x88,0x89,0x97,0x98,0xA6,0xA7,0xB5,0xB6,0xC4,0xC5,0xD3,0xD4,0xE2,0xE3,0xF1,0xF2,
0x12,0x14,0x13,0x15,0x21,0x23,0x22,0x24,0x30,0x32,0x31,0x33,0x3F,0x41,0x40,0x42,
0x4E,0x50,0x4F,0x51,0x5D,0x5F,0x5E,0x60,0x6C,0x6E,0x6D,0x6F,0x7B,0x7D,0x7C,0x7E,
0x8A,0x8C,0x8B,0x8D,0x99,0x9B,0x9A,0x9C,0xA8,0xAA,0xA9,0xAB,0xB7,0xB9,0xB8,0xBA,
0xC6,0xC8,0xC7,0xC9,0xD5,0xD7,0xD6,0xD8,0xE4,0xE6,0xE5,0xE7,0xF3,0xF5,0xF4,0xF6,
0x16,0x1A,0x18,0x1C,0x17,0x1B,0x19,0x1D,0x25,0x29,0x27,0x2B,0x26,0x2A,0x28,0x2C,
0x34,0x38,0x36,0x3A,0x35,0x39,0x37,0x3B,0x43,0x47,0x45,0x49,0x44,0x48,0x46,0x4A,
0x52,0x56,0x54,0x58,0x53,0x57,0x55,0x59,0x61,0x65,0x63,0x67,0x62,0x66,0x64,0x68,
0x70,0x74,0x72,0x76,0x71,0x75,0x73,0x77,0x7F,0x83,0x81,0x85,0x80,0x84,0x82,0x86,
0x8E,0x92,0x90,0x94,0x8F,0x93,0x91,0x95,0x9D,0xA1,0x9F,0xA3,0x9E,0xA2,0xA0,0xA4,
0xAC,0xB0,0xAE,0xB2,0xAD,0xB1,0xAF,0xB3,0xBB,0xBF,0xBD,0xC1,0xBC,0xC0,0xBE,0xC2,
0xCA,0xCE,0xCC,0xD0,0xCB,0xCF,0xCD,0xD1,0xD9,0xDD,0xDB,0xDF,0xDA,0xDE,0xDC,0xE0,
0xE8,0xEC,0xEA,0xEE,0xE9,0xED,0xEB,0xEF,0xF7,0xFB,0xF9,0xFD,0xF8,0xFC,0xFA,0xFE,
};

#include "tables.inc"
#include "CMB.inc"
#include "CM.inc"

//#include "valloc.inc"

#include "coro3b_fake.inc"

#include "coro_fp2.inc"

#include "sh_v1x.inc"


template< int f_DEC >
struct Model : Rangecoder<f_DEC>,CM {

  uint f_len;

  void Init( void ) {
  }

  void Quit( void ) {
  }

  void do_process( void ) {
    uint i,k,c,sym,bit; int p;

#if 0
    for( c=0; c<256; c++ ) {
      uint ofs=0;
      for( k=0,sym=1; sym<0x100; k++ ) {
        bit = (c>>(7-k))&1;
        if( k==4 ) ofs = 15*(sym-15); else ofs += (bit+1) << ((k&3)-1);
        sym += sym+bit;
        L_LUT[sym] = ofs;
      }
    }
#endif

    rc_Init();

    for( i=0; i<f_len; i++ ) {
      if( f_DEC==0 ) { c = get(); if( c==-1 ) break; }

      for( sym=1,k=7; sym<0x100; k-- ) {
        bit=0; if( f_DEC==0 ) bit=(c>>k)&1;

        p = next_probability;
        p = SCALE-(p<<(SCALElog-P_LOG));
        if_e0( p<1 ) p=1;
        if_e0( p>mSCALE ) p=mSCALE;

        bit = rc_BProcess(p,bit);

        CM_Update( bit );

        sym += sym+bit;
      }

      if( f_DEC==1 ) put(sym);
    }

    rc_Quit();

    yield(this,0);
  }

};


static union {
  CoroFileProc< Model<0> > C;
  CoroFileProc< Model<1> > D;
};

int main( int argc, char** argv ) {

//const byte kLzModelLNext[256*2] = {
#if 0
  uint i;
  for( i=0; i<256; i++ ) {
    printf( "{%3i,%3i},", kLzModelLNext[2*i+0],kLzModelLNext[2*i+1] );
    if( i%8==7 ) printf( "\n" );
  }
#endif

  if( argc<4 ) return 1;

  Build_kModelInterpolation();
  CM_InitTables();
  LzCreateTables();

  uint f_DEC = (argv[1][0]=='d');
  FILE* f = fopen(argv[2],"rb"); if( f==0 ) return 2;
  FILE* g = fopen(argv[3],"wb"); if( g==0 ) return 3;

  uint f_len;

  if( f_DEC==0 ) {
    f_len = flen(f);
    fwrite( &f_len,1,4,g );
    C.f_len = f_len; C._f=f; C._g=g;
    C.CM_Init( 28, 25, 1048576 );
    C.processfile( f, g );
  } else {
    f_len=0; fread( &f_len,1,4,f );
    D.f_len = f_len; D._f=f; D._g=g;
    D.CM_Init( 28, 25, 1048576 );
    D.processfile( f, g );
  }

  fclose(g);
  fclose(f);

  return 0;
}
